<#
.SYNOPSIS
    Restructures existing documents to match Document Structure Guidelines

.DESCRIPTION
    This script analyzes existing documents, maps their content to the Document Structure Guidelines,
    reorganizes the content according to the structure, and commits changes with auto-generated comments.
    
    It performs 4 main steps:
    Step 1: Verify document content for completeness
    Step 2: Read existing content and create mapping to Document Structure
    Step 3: Rewrite content as per structure
    Step 4: Commit change with autogenerated comments

.PARAMETER FilePath
    Path to the document file to restructure

.PARAMETER Recursive
    Process all markdown files in directory recursively

.PARAMETER DryRun
    Preview changes without actually modifying files

.PARAMETER AutoCommit
    Automatically commit changes to Git (default: false)

.EXAMPLE
    .\Restructure-Documents.ps1 -FilePath "./00_Policy/ELA_Development_Policy.md"

.EXAMPLE
    .\Restructure-Documents.ps1 -FilePath "./02_Design" -Recursive -AutoCommit

.NOTES
    Author: ETA Framework Team
    Version: 1.0.0  Document Structure Enforcement
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$FilePath,

    [Parameter(Mandatory = $false)]
    [switch]$Recursive,

    [Parameter(Mandatory = $false)]
    [switch]$DryRun,

    [Parameter(Mandatory = $false)]
    [switch]$AutoCommit
)

# STEP 1: Load Document Structure Guidelines
function Get-DocumentStructure {
    param([string]$RepoRoot)
    
    $structurePath = Join-Path $RepoRoot "00_Policy/Document_Structure_Guidelines.md"
    
    if (-not (Test-Path $structurePath)) {
        Write-Warning "Document_Structure_Guidelines.md not found at: $structurePath"
        return $null
    }
    
    Write-Host "Loading Document Structure Guidelines..." -ForegroundColor Cyan
    $content = Get-Content $structurePath -Raw
    
    # Define standard document sections based on guidelines
    $structure = @{
        'YAML_Frontmatter' = @('artifact_id', 'version', 'status', 'owner', 'last_updated', 'phase', 'dependencies')
        'Title' = 'Required'
        'Sections' = @(
            '1. Purpose',
            '2. Scope',
            '3. Definitions',
            '4. Requirements',
            '5. Implementation',
            '6. Validation',
            '7. References',
            '8. Appendices'
        )
    }
    
    Write-Host "Document structure loaded successfully" -ForegroundColor Green
    return $structure
}

# STEP 2: Analyze and verify document content
function Test-DocumentCompleteness {
    param(
        [string]$Content,
        [hashtable]$Structure
    )
    
    $analysis = @{
        'HasYAML' = $false
        'HasTitle' = $false
        'MissingSections' = @()
        'ExistingSections' = @()
        'Content Blocks' = @()
    }
    
    # Check for YAML frontmatter
    if ($Content -match "(?ms)^---\s*\n(.+?)\n---") {
        $analysis.HasYAML = $true
    }
    
    # Check for H1 title
    if ($Content -match "(?m)^# .+") {
        $analysis.HasTitle = $true
    }
    
    # Check for required sections
    foreach ($section in $Structure.Sections) {
        if ($Content -match "(?m)^##\s+$([regex]::Escape($section))") {
            $analysis.ExistingSections += $section
        } else {
            $analysis.MissingSections += $section
        }
    }
    
    return $analysis
}

# STEP 3: Map existing content to structure
function Get-ContentMapping {
    param(
        [string]$Content,
        [hashtable]$Structure
    )
    
    Write-Host "Analyzing existing content..." -ForegroundColor Cyan
    
    $mapping = @{}
    
    # Extract YAML
    if ($Content -match "(?ms)^---\s*\n(.+?)\n---") {
        $mapping['YAML'] = $Matches[0]
    } else {
        $mapping['YAML'] = $null
    }
    
    # Extract title
    if ($Content -match "(?m)^# (.+)$") {
        $mapping['Title'] = $Matches[1]
    } else {
        $mapping['Title'] = 'Untitled Document'
    }
    
    # Extract content by sections
    $lines = $Content -split "\r?\n"
    $currentSection = 'preamble'
    $sectionContent = @{}
    $sectionContent[$currentSection] = @()
    
    foreach ($line in $lines) {
        if ($line -match "^##\s+(.+)") {
            $currentSection = $Matches[1]
            $sectionContent[$currentSection] = @()
        } else {
            if ($sectionContent.ContainsKey($currentSection)) {
                $sectionContent[$currentSection] += $line
            }
        }
    }
    
    $mapping['Sections'] = $sectionContent
    
    Write-Host "Content mapped: $($sectionContent.Keys.Count) sections found" -ForegroundColor Green
    return $mapping
}

# STEP 4: Restructure document according to guidelines
function New-RestructuredDocument {
    param(
        [hashtable]$Mapping,
        [hashtable]$Structure,
        [hashtable]$Analysis
    )
    
    Write-Host "Restructuring document..." -ForegroundColor Yellow
    
    $restructured = @()
    
    # Add YAML frontmatter
    if ($Mapping.YAML) {
        $restructured += $Mapping.YAML
        $restructured += ""
    } else {
        Write-Warning "No YAML frontmatter found - document should have metadata"
    }
    
    # Add title
    $restructured += "# $($Mapping.Title)"
    $restructured += ""
    
    # Add structured sections in order
    foreach ($sectionName in $Structure.Sections) {
        $restructured += "## $sectionName"
        $restructured += ""
        
        # Find matching content from original
        $found = $false
        foreach ($existingSection in $Mapping.Sections.Keys) {
            if ($existingSection -match $sectionName -or $sectionName -match $existingSection) {
                $sectionLines = $Mapping.Sections[$existingSection] | Where-Object { $_ -notmatch "^##\s+" }
                $restructured += $sectionLines
                $restructured += ""
                $found = $true
                break
            }
        }
        
        if (-not $found) {
            $restructured += "*[To be completed]*"
            $restructured += ""
        }
    }
    
    Write-Host "Document restructured successfully" -ForegroundColor Green
    return ($restructured -join "`n")
}

# Generate commit message
function New-CommitMessage {
    param(
        [string]$FilePath,
        [hashtable]$Analysis
    )
    
    $filename = Split-Path $FilePath -Leaf
    $changes = @()
    
    if (-not $Analysis.HasYAML) { $changes += "add YAML frontmatter" }
    if ($Analysis.MissingSections.Count -gt 0) {
        $changes += "add $($Analysis.MissingSections.Count) missing sections"
    }
    $changes += "enforce structure"
    
    $message = "docs: restructure $filename - $($changes -join ', ')"
    return $message
}

# Process single document
function Invoke-DocumentRestructure {
    param(
        [string]$FilePath,
        [hashtable]$Structure,
        [string]$RepoRoot
    )
    
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "Processing: $FilePath" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    
    # Step 1: Read existing content
    $content = Get-Content $FilePath -Raw -ErrorAction Stop
    
    # Step 2: Verify completeness
    $analysis = Test-DocumentCompleteness -Content $content -Structure $Structure
    
    Write-Host "`nSTEP 1: Content Analysis" -ForegroundColor Yellow
    Write-Host "  YAML Frontmatter: $(if ($analysis.HasYAML) {'Yes'} else {'Missing'})" -ForegroundColor $(if ($analysis.HasYAML) {'Green'} else {'Red'})
    Write-Host "  Title: $(if ($analysis.HasTitle) {'Yes'} else {'Missing'})" -ForegroundColor $(if ($analysis.HasTitle) {'Green'} else {'Red'})
    Write-Host "  Existing Sections: $($analysis.ExistingSections.Count)" -ForegroundColor Cyan
    Write-Host "  Missing Sections: $($analysis.MissingSections.Count)" -ForegroundColor $(if ($analysis.MissingSections.Count -eq 0) {'Green'} else {'Yellow'})
    
    if ($analysis.MissingSections.Count -gt 0) {
        Write-Host "  Missing: $($analysis.MissingSections -join ', ')" -ForegroundColor Yellow
    }
    
    # Step 3: Map content
    Write-Host "`nSTEP 2: Content Mapping" -ForegroundColor Yellow
    $mapping = Get-ContentMapping -Content $content -Structure $Structure
    
    # Step 4: Restructure
    Write-Host "`nSTEP 3: Document Restructuring" -ForegroundColor Yellow
    $newContent = New-RestructuredDocument -Mapping $mapping -Structure $Structure -Analysis $analysis
    
    return @{
        'NewContent' = $newContent
        'Analysis' = $analysis
    }
}

# Main script execution
try {
    Write-Host "`n╔════════════════════════════════════════╗" -ForegroundColor Magenta
    Write-Host "║  Document Structure Enforcement Tool  ║" -ForegroundColor Magenta
    Write-Host "║  Version 1.0.0                         ║" -ForegroundColor Magenta
    Write-Host "╚════════════════════════════════════════╝`n" -ForegroundColor Magenta
    
    # Find repository root
    $repoRoot = (Get-Location).Path
    while (-not (Test-Path (Join-Path $repoRoot ".git")) -and $repoRoot -ne [System.IO.Path]::GetPathRoot($repoRoot)) {
        $repoRoot = Split-Path $repoRoot -Parent
    }
    
    if (-not (Test-Path (Join-Path $repoRoot ".git"))) {
        Write-Warning "Not in a Git repository. Using current directory as root."
        $repoRoot = (Get-Location).Path
    }
    
    Write-Host "Repository root: $repoRoot`n" -ForegroundColor Gray
    
    # Load structure
    $structure = Get-DocumentStructure -RepoRoot $repoRoot
    if (-not $structure) {
        throw "Could not load Document Structure Guidelines"
    }
    
    # Get files to process
    $filesToProcess = @()
    
    if ($Recursive) {
        $targetPath = Join-Path $repoRoot $FilePath
        if (Test-Path $targetPath -PathType Container) {
            $filesToProcess = Get-ChildItem -Path $targetPath -Recurse -Filter *.md | Where-Object { $_.Name -ne 'README.md' }
            Write-Host "Found $($filesToProcess.Count) markdown files to process`n" -ForegroundColor Cyan
        } else {
            throw "Directory not found: $targetPath"
        }
    } else {
        $fullPath = if ([System.IO.Path]::IsPathRooted($FilePath)) { $FilePath } else { Join-Path $repoRoot $FilePath }
        if (-not (Test-Path $fullPath)) {
            throw "File not found: $fullPath"
        }
        $filesToProcess = @(Get-Item $fullPath)
    }
    
    # Process each file
    $processedCount = 0
    $skippedCount = 0
    $commitMessages = @()
    
    foreach ($file in $filesToProcess) {
        try {
            $result = Invoke-DocumentRestructure -FilePath $file.FullName -Structure $structure -RepoRoot $repoRoot
            
            if ($DryRun) {
                Write-Host "`nSTEP 4: DRY RUN - No changes written" -ForegroundColor Yellow
                Write-Host "Preview of restructured content:" -ForegroundColor Gray
                Write-Host "$($result.NewContent.Substring(0, [Math]::Min(500, $result.NewContent.Length)))..." -ForegroundColor Gray
            } else {
                # Write new content
                Write-Host "`nSTEP 4: Writing Changes" -ForegroundColor Yellow
                Set-Content -Path $file.FullName -Value $result.NewContent -NoNewline -Force
                Write-Host "  File updated successfully" -ForegroundColor Green
                
                # Generate commit message
                $commitMsg = New-CommitMessage -FilePath $file.FullName -Analysis $result.Analysis
                $commitMessages += @{
                    'File' = $file.FullName
                    'Message' = $commitMsg
                }
                
                $processedCount++
            }
            
        } catch {
            Write-Error "Error processing $($file.Name): $_"
            $skippedCount++
        }
    }
    
    # Git commit if requested
    if ($AutoCommit -and -not $DryRun -and $processedCount -gt 0) {
        Write-Host "`n========================================" -ForegroundColor Magenta
        Write-Host "Committing Changes to Git" -ForegroundColor Magenta
        Write-Host "========================================" -ForegroundColor Magenta
        
        foreach ($commit in $commitMessages) {
            $relativePath = $commit.File -replace [regex]::Escape($repoRoot), "" -replace "^[\\/]", ""
            Write-Host "`nCommitting: $relativePath" -ForegroundColor Cyan
            
            try {
                # Stage file
                & git add $commit.File
                
                # Commit with generated message
                & git commit -m $commit.Message
                
                Write-Host "  Committed: $($commit.Message)" -ForegroundColor Green
            } catch {
                Write-Warning "  Git commit failed: $_"
            }
        }
    }
    
    # Summary
    Write-Host "`n╔════════════════════════════════════════╗" -ForegroundColor Magenta
    Write-Host "║        Processing Complete            ║" -ForegroundColor Magenta
    Write-Host "╚════════════════════════════════════════╝" -ForegroundColor Magenta
    Write-Host "Processed: $processedCount files" -ForegroundColor Green
    if ($skippedCount -gt 0) {
        Write-Host "Skipped: $skippedCount files" -ForegroundColor Yellow
    }
    if ($DryRun) {
        Write-Host "Mode: DRY RUN (no changes written)" -ForegroundColor Yellow
    }
    if ($AutoCommit -and -not $DryRun) {
        Write-Host "Changes committed to Git" -ForegroundColor Green
    }
    
    Write-Host ""
    
} catch {
    Write-Error "Fatal error: $_"
    Write-Error $_.ScriptStackTrace
    exit 1
}
