<#
.SYNOPSIS
    Restructures existing documents to match Document Structure Guidelines for ALL artifact types

.DESCRIPTION
    This script analyzes existing documents/artifacts, maps their content to the Document Structure Guidelines,
    reorganizes the content according to type-specific structures, and commits changes with auto-generated comments.
    
    Supports ALL artifact types: DOC, TMP, GDL, VAL, WFL, SCR, IMG, CFG, TST, DAT, INST
    
    It performs 4 main steps:
    Step 1: Verify document content for completeness
    Step 2: Read existing content and create mapping to Document Structure
    Step 3: Rewrite content as per type-specific structure
    Step 4: Commit change with autogenerated comments

.PARAMETER FilePath
    Path to the document/artifact file to restructure

.PARAMETER Recursive
    Process all files in directory recursively

.PARAMETER DryRun
    Preview changes without actually modifying files

.PARAMETER AutoCommit
    Automatically commit changes to Git (default: false)

.EXAMPLE
    .\Restructure-Documents.ps1 -FilePath "./00_Policy/ELA_Development_Policy.md"

.EXAMPLE
    .\Restructure-Documents.ps1 -FilePath "./02_Design" -Recursive -AutoCommit

.EXAMPLE
    .\Restructure-Documents.ps1 -FilePath "./Tools/Scripts/Add-ArtifactMetadata.ps1" -DryRun

.NOTES
    Author: ETA Framework Team
    Version: 2.0.0  All Artifact Types Support
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $true)]
    [string]$FilePath,

    [Parameter(Mandatory = $false)]
    [switch]$Recursive,

    [Parameter(Mandatory = $false)]
    [switch]$DryRun,

    [Parameter(Mandatory = $false)]
    [switch]$AutoCommit
)

# STEP 1: Load Document Structure Guidelines and parse type-specific structures
function Get-DocumentStructure {
    param([string]$RepoRoot)
    
    $structurePath = Join-Path $RepoRoot "00_Policy/Document_Structure_Guidelines.md"
    
    if (-not (Test-Path $structurePath)) {
        Write-Warning "Document_Structure_Guidelines.md not found at: $structurePath"
        return $null
    }
    
    Write-Host "Loading Document Structure Guidelines..." -ForegroundColor Cyan
    
    # Define type-specific structures based on Document_Structure_Guidelines.md Section 5
    $structures = @{}
    
    # DOC - Documentation (Section 5.1)
    $structures['DOC'] = @{
        'Type' = 'DOC'
        'FileTypes' = @('.md', '.docx')
        'Sections' = @(
            '1. Purpose',
            '2. Scope',
            '3. [Primary Content Sections]',
            'N. Compliance & Standards',
            'N+1. Exceptions',
            'N+2. References'
        )
    }
    
    # TMP - Template (Section 5.2)
    $structures['TMP'] = @{
        'Type' = 'TMP'
        'FileTypes' = @('.md')
        'Sections' = @(
            '1. Template Purpose',
            '2. When to Use This Template',
            '3. Prerequisites',
            '4. Instructions',
            '5. [Template Content Sections]',
            '6. Validation',
            '7. Related Templates'
        )
    }
    
    # GDL - Guideline (Section 5.3)
    $structures['GDL'] = @{
        'Type' = 'GDL'
        'FileTypes' = @('.md')
        'Sections' = @(
            '1. Purpose',
            '2. Audience',
            '3. Process Overview',
            '4. Detailed Steps',
            '5. Examples',
            '6. Common Pitfalls',
            '7. Resources'
        )
    }
    
    # GDL-Process_Overview (Section 5.4)
    $structures['GDL-PROCESS'] = @{
        'Type' = 'GDL'
        'Subtype' = 'Process_Overview'
        'FileTypes' = @('.md')
        'Sections' = @(
            '1. Phase Overview',
            '2. Process Groups',
            '3. Workflow Diagram',
            '4. Entry & Exit Criteria',
            '5. Roles & Responsibilities',
            '6. Phase Completion Checklist'
        )
    }
    
    # VAL - Validation Checklist (Section 5.5)
    $structures['VAL'] = @{
        'Type' = 'VAL'
        'FileTypes' = @('.md')
        'Sections' = @(
            '1. Validation Purpose',
            '2. Entry Criteria',
            '3. Checklist Items',
            '4. Exit Criteria',
            '5. Failed Validation Response'
        )
    }
    
    # WFL - Workflow (Section 5.6)
    $structures['WFL'] = @{
        'Type' = 'WFL'
        'FileTypes' = @('.yml', '.yaml', '.md')
        'Sections' = @(
            '1. Workflow Purpose',
            '2. Trigger Conditions',
            '3. Prerequisites',
            '4. Workflow Steps',
            '5. Expected Outputs',
            '6. Error Handling',
            '7. Maintenance'
        )
    }
    
    # INST - Instance (Section 5.7)
    $structures['INST'] = @{
        'Type' = 'INST'
        'FileTypes' = @('.md')
        'Sections' = @(
            '1. Instance Metadata',
            '2. [Template Content Sections]',
            '3. Validation Record',
            '4. Change History'
        )
    }
    
    # SCR - Script
    $structures['SCR'] = @{
        'Type' = 'SCR'
        'FileTypes' = @('.ps1', '.py', '.sh', '.js')
        'Sections' = @(
            'Synopsis',
            'Description',
            'Parameters',
            'Examples',
            'Notes'
        )
    }
    
    # IMG - Image
    $structures['IMG'] = @{
        'Type' = 'IMG'
        'FileTypes' = @('.png', '.jpg', '.jpeg', '.svg')
        'Sections' = @(
            '1. Image Description',
            '2. Context & Usage',
            '3. Alt Text',
            '4. Related Artifacts'
        )
    }
    
    # CFG - Configuration
    $structures['CFG'] = @{
        'Type' = 'CFG'
        'FileTypes' = @('.json', '.yaml', '.yml', '.xml', '.config')
        'Sections' = @(
            'Configuration Purpose',
            'Key Structure',
            'Environment-Specific Settings',
            'Validation Rules'
        )
    }
    
    # TST - Test
    $structures['TST'] = @{
        'Type' = 'TST'
        'FileTypes' = @('.md', '.ps1', '.py')
        'Sections' = @(
            '1. Test Purpose',
            '2. Test Plan',
            '3. Test Cases',
            '4. Expected Results',
            '5. Actual Results'
        )
    }
    
    # DAT - Data
    $structures['DAT'] = @{
        'Type' = 'DAT'
        'FileTypes' = @('.csv', '.json', '.xml')
        'Sections' = @(
            '1. Data Description',
            '2. Data Dictionary',
            '3. Schema',
            '4. Source & Lineage',
            '5. Update Frequency'
        )
    }
    
    Write-Host "Structure templates loaded: $($structures.Keys.Count) artifact types" -ForegroundColor Green
    return $structures
}

# Detect artifact type from YAML or file extension
function Get-ArtifactType {
    param(
        [string]$FilePath,
        [string]$Content
    )
    
    # Try to extract from YAML frontmatter first
    if ($Content -match "(?ms)^---\s*\n.*?^artifact_type\s*:\s*['\"]?([A-Z]+)['\"]?\s*$.*?^---") {
        return $Matches[1]
    }
    
    # Fall back to file extension detection
    $extension = [System.IO.Path]::GetExtension($FilePath).ToLower()
    
    switch ($extension) {
        { $_ -in @('.ps1', '.py', '.sh', '.js') } { return 'SCR' }
        { $_ -in @('.yml', '.yaml') } { return 'WFL' }
        { $_ -in @('.json', '.xml', '.config') } { return 'CFG' }
        { $_ -in @('.png', '.jpg', '.jpeg', '.svg') } { return 'IMG' }
        { $_ -in @('.csv') } { return 'DAT' }
        { $_ -in @('.md', '.docx') } {
            # For markdown, try to determine subtype from content
            if ($Content -match 'Template Purpose|{{[A-Z_]+}}') { return 'TMP' }
            if ($Content -match 'Validation Purpose|Checklist Items') { return 'VAL' }
            if ($Content -match 'Process Overview|Process Groups') { return 'GDL-PROCESS' }
            if ($Content -match 'Audience|Detailed Steps') { return 'GDL' }
            if ($Content -match 'template_source|Instance Metadata') { return 'INST' }
            if ($Content -match 'Test Purpose|Test Cases') { return 'TST' }
            return 'DOC'
        }
        default { return 'DOC' }
    }
}

# Get appropriate structure for artifact type
function Get-StructureForType {
    param(
        [string]$ArtifactType,
        [hashtable]$AllStructures
    )
    
    if ($AllStructures.ContainsKey($ArtifactType)) {
        return $AllStructures[$ArtifactType]
    }
    
    # Default to DOC if type not found
    Write-Warning "Unknown artifact type: $ArtifactType. Using DOC structure."
    return $AllStructures['DOC']
}

# STEP 2: Analyze and verify document completeness
function Test-DocumentCompleteness {
    param(
        [string]$Content,
        [hashtable]$Structure,
        [string]$FilePath
    )
    
    $analysis = @{
        'HasYAML' = $false
        'HasTitle' = $false
        'HasMetadataSection' = $false
        'MissingSections' = @()
        'ExistingSections' = @()
        'ArtifactType' = 'Unknown'
        'FileType' = [System.IO.Path]::GetExtension($FilePath)
    }
    
    # Check for YAML frontmatter
    if ($Content -match "(?ms)^---\s*\n(.+?)\n---") {
        $analysis.HasYAML = $true
    }
    
    # Check for H1 title (for markdown)
    if ($Content -match "(?m)^# .+") {
        $analysis.HasTitle = $true
    }
    
    # Check for Section 0 Metadata
    if ($Content -match "(?m)^##\s+0\.\s*Metadata") {
        $analysis.HasMetadataSection = $true
    }
    
    # Check for required sections
    foreach ($section in $Structure.Sections) {
        $sectionPattern = [regex]::Escape($section) -replace '\\\[.*?\\\]', '.*'
        if ($Content -match "(?m)^##\s+$sectionPattern") {
            $analysis.ExistingSections += $section
        } else {
            $analysis.MissingSections += $section
        }
    }
    
    return $analysis
}

# STEP 3: Map existing content to structure
function Get-ContentMapping {
    param(
        [string]$Content,
        [hashtable]$Structure,
        [string]$FilePath
    )
    
    Write-Host "Analyzing existing content..." -ForegroundColor Cyan
    
    $mapping = @{}
    $extension = [System.IO.Path]::GetExtension($FilePath).ToLower()
    
    # Extract YAML
    if ($Content -match "(?ms)^---\s*\n(.+?)\n---") {
        $mapping['YAML'] = $Matches[0]
    } else {
        $mapping['YAML'] = $null
    }
    
    # Extract title
    if ($Content -match "(?m)^# (.+)$") {
        $mapping['Title'] = $Matches[1]
    } else {
        $mapping['Title'] = [System.IO.Path]::GetFileNameWithoutExtension($FilePath)
    }
    
    # Handle different file types
    switch ($extension) {
        { $_ -in @('.ps1', '.py', '.sh') } {
            # Extract script header
            $mapping['ScriptHeader'] = $null
            if ($Content -match "(?ms)^(<#.*?#>|'''.*?'''|""",.*?""")") {
                $mapping['ScriptHeader'] = $Matches[0]
            }
            $mapping['ScriptBody'] = $Content
        }
        { $_ -in @('.yml', '.yaml', '.json', '.xml') } {
            # For structured files, store as-is
            $mapping['StructuredContent'] = $Content
        }
        { $_ -in @('.png', '.jpg', '.jpeg', '.svg') } {
            # For images, check for companion .md file
            $companionMd = $FilePath -replace '\.[^.]+$', '.md'
            if (Test-Path $companionMd) {
                $mapping['CompanionDoc'] = Get-Content $companionMd -Raw
            }
        }
        default {
            # Extract content by sections (markdown)
            $lines = $Content -split "\r?\n"
            $currentSection = 'preamble'
            $sectionContent = @{}
            $sectionContent[$currentSection] = @()
            
            foreach ($line in $lines) {
                if ($line -match "^##\s+(.+)") {
                    $currentSection = $Matches[1]
                    $sectionContent[$currentSection] = @()
                } else {
                    if ($sectionContent.ContainsKey($currentSection)) {
                        $sectionContent[$currentSection] += $line
                    }
                }
            }
            
            $mapping['Sections'] = $sectionContent
        }
    }
    
    Write-Host "Content mapped: $($mapping.Keys.Count) elements found" -ForegroundColor Green
    return $mapping
}

# STEP 4: Restructure document according to type-specific guidelines
function New-RestructuredDocument {
    param(
        [hashtable]$Mapping,
        [hashtable]$Structure,
        [hashtable]$Analysis,
        [string]$FilePath,
        [string]$ArtifactType
    )
    
    Write-Host "Restructuring document for type: $ArtifactType" -ForegroundColor Yellow
    
    $extension = [System.IO.Path]::GetExtension($FilePath).ToLower()
    
    # Handle non-markdown files
    if ($extension -in @('.ps1', '.py', '.sh')) {
        return New-RestructuredScript -Mapping $Mapping -Structure $Structure -FilePath $FilePath
    }
    if ($extension -in @('.yml', '.yaml', '.json')) {
        return New-RestructuredConfig -Mapping $Mapping -Structure $Structure -FilePath $FilePath
    }
    if ($extension -in @('.png', '.jpg', '.jpeg', '.svg')) {
        return New-ImageCompanionDoc -Mapping $Mapping -Structure $Structure -FilePath $FilePath
    }
    if ($extension -eq '.csv') {
        return New-DataDocumentation -Mapping $Mapping -Structure $Structure -FilePath $FilePath
    }
    
    # Handle markdown files
    $restructured = @()
    
    # Add YAML frontmatter
    if ($Mapping.YAML) {
        $restructured += $Mapping.YAML
        $restructured += ""
    } else {
        Write-Warning "No YAML frontmatter - consider adding metadata"
    }
    
    # Add title
    $restructured += "# $($Mapping.Title)"
    $restructured += ""
    
    # Add Section 0: Metadata (if not present)
    if (-not $Analysis.HasMetadataSection) {
        $restructured += "## 0. Metadata"
        $restructured += ""
        $restructured += "- **Artifact ID**: [To be assigned]"
        $restructured += "- **Version**: v1.0"
        $restructured += "- **Owner**: [Team Name]"
        $restructured += "- **Last Updated**: $(Get-Date -Format 'yyyy-MM-dd')"
        $restructured += ""
        $restructured += "---"
        $restructured += ""
    }
    
    # Add structured sections in order
    foreach ($sectionName in $Structure.Sections) {
        # Skip placeholder sections
        if ($sectionName -match '\[.*\]' -and $sectionName -notmatch '^\d+\.') {
            continue
        }
        
        $restructured += "## $sectionName"
        $restructured += ""
        
        # Find matching content from original
        $found = $false
        if ($Mapping.Sections) {
            foreach ($existingSection in $Mapping.Sections.Keys) {
                $cleanSectionName = $sectionName -replace '^\d+\.\s*', ''
                $cleanExistingName = $existingSection -replace '^\d+\.\s*', ''
                
                if ($cleanExistingName -match $cleanSectionName -or $cleanSectionName -match $cleanExistingName) {
                    $sectionLines = $Mapping.Sections[$existingSection] | Where-Object { $_ -notmatch "^##\s+" }
                    if ($sectionLines) {
                        $restructured += $sectionLines
                        $restructured += ""
                        $found = $true
                        break
                    }
                }
            }
        }
        
        if (-not $found) {
            $restructured += "*[Content to be added]*"
            $restructured += ""
        }
    }
    
    Write-Host "Document restructured successfully" -ForegroundColor Green
    return ($restructured -join "`n")
}

# Helper: Restructure script files (.ps1, .py, .sh)
function New-RestructuredScript {
    param($Mapping, $Structure, $FilePath)
    
    $extension = [System.IO.Path]::GetExtension($FilePath)
    $commentStart = if ($extension -eq '.ps1') { '<#' } elseif ($extension -eq '.py') { '"""' } else { ': <<COMMENT' }
    $commentEnd = if ($extension -eq '.ps1') { '#>' } elseif ($extension -eq '.py') { '"""' } else { 'COMMENT' }
    
    # Build proper comment header
    $header = @()
    $header += $commentStart
    $header += ".SYNOPSIS"
    $header += "    [Script purpose description]"
    $header += ""
    $header += ".DESCRIPTION"
    $header += "    [Detailed description]"
    $header += ""
    $header += ".NOTES"
    $header += "    Version: 1.0"
    $header += "    Last Updated: $(Get-Date -Format 'yyyy-MM-dd')"
    $header += $commentEnd
    $header += ""
    
    # Keep original script body
    $body = if ($Mapping.ScriptBody) { $Mapping.ScriptBody -replace '(?ms)^<#.*?#>', '' } else { '' }
    
    return (($header -join "`n") + "`n" + $body)
}

# Helper: Create companion doc for images
function New-ImageCompanionDoc {
    param($Mapping, $Structure, $FilePath)
    
    $imageName = Split-Path $FilePath -Leaf
    $companionPath = $FilePath -replace '\.[^.]+$', '.md'
    
    $doc = @()
    $doc += "# Image: $imageName"
    $doc += ""
    $doc += "## 1. Image Description"
    $doc += ""
    $doc += "[Describe what this image shows]"
    $doc += ""
    $doc += "## 2. Context & Usage"
    $doc += ""
    $doc += "**Used in**: [List of artifacts that reference this image]"
    $doc += ""
    $doc += "## 3. Alt Text"
    $doc += ""
    $doc += "Alt text for accessibility: [Descriptive alt text]"
    $doc += ""
    $doc += "## 4. Related Artifacts"
    $doc += ""
    $doc += "- [List related artifacts]"
    
    return ($doc -join "`n")
}

# Helper: Create data documentation
function New-DataDocumentation {
    param($Mapping, $Structure, $FilePath)
    
    $dataName = Split-Path $FilePath -Leaf
    $readmePath = (Split-Path $FilePath -Parent) + "/README_" + $dataName -replace '\.csv$', '.md'
    
    $doc = @()
    $doc += "# Data File: $dataName"
    $doc += ""
    $doc += "## 1. Data Description"
    $doc += ""
    $doc += "[Description of data content and purpose]"
    $doc += ""
    $doc += "## 2. Data Dictionary"
    $doc += ""
    $doc += "| Column | Type | Description | Example |"
    $doc += "|--------|------|-------------|---------|" 
    $doc += "| [name] | [type] | [description] | [example] |"
    $doc += ""
    $doc += "## 3. Schema"
    $doc += ""
    $doc += "[Schema definition]"
    $doc += ""
    $doc += "## 4. Source & Lineage"
    $doc += ""
    $doc += "**Source**: [Data source]"
    $doc += "**Last Updated**: $(Get-Date -Format 'yyyy-MM-dd')"
    
    return ($doc -join "`n")
}

# Helper: Restructure config files
function New-RestructuredConfig {
    param($Mapping, $Structure, $FilePath)
    # For config files, add comments at the top
    $header = "# Configuration File\n# Purpose: [Add purpose]\n# Last Updated: $(Get-Date -Format 'yyyy-MM-dd')\n\n"
    return $header + $Mapping.StructuredContent
}

# Generate commit message
function New-CommitMessage {
    param([string]$FilePath, [hashtable]$Analysis, [string]$ArtifactType)
    
    $filename = Split-Path $FilePath -Leaf
    $changes = @()
    
    if (-not $Analysis.HasYAML) { $changes += "add YAML metadata" }
    if (-not $Analysis.HasMetadataSection) { $changes += "add Section 0" }
    if ($Analysis.MissingSections.Count -gt 0) {
        $changes += "add $($Analysis.MissingSections.Count) sections"
    }
    $changes += "enforce $ArtifactType structure"
    
    return "docs($ArtifactType): restructure $filename - $($changes -join ', ')"
}

# ============================================================================
# STEP 4: Orchestrate Document Restructuring
# ============================================================================

function Invoke-DocumentRestructure {
    param(
        [string]$FilePath,
        [hashtable]$Structure,
        [bool]$IsScript
    )
    
    try {
        # Step 1: Read content and detect artifact type
        Write-Host "Processing: $FilePath" -ForegroundColor Cyan
        $content = Get-Content $FilePath -Raw
        $artifactType = Get-ArtifactType -FilePath $FilePath -Content $content
        Write-Host "  Detected Type: $artifactType" -ForegroundColor Gray
        
        # Step 2: Verify completeness
        $analysis = Test-DocumentCompleteness -Content $content -Structure $Structure
        if ($analysis.HasYAML) {
            Write-Host "  Has YAML metadata: Yes" -ForegroundColor Gray
        } else {
            Write-Host "  Has YAML metadata: No" -ForegroundColor Gray
        }
        
        if ($analysis.MissingSections.Count -gt 0) {
            Write-Host "  Missing sections: $($analysis.MissingSections -join ', ')" -ForegroundColor Yellow
        } else {
            Write-Host "  All sections present" -ForegroundColor Green
        }
        
        # Step 3: Map content
        $mapping = Get-ContentMapping -Content $content -Structure $Structure -IsScript $IsScript
        
        # Step 4: Restructure
        $restructured = New-RestructuredDocument -Mapping $mapping -Structure $Structure -IsScript $IsScript -FilePath $FilePath -Analysis $analysis -ArtifactType $artifactType
        
        return @{
            OriginalContent = $content
            RestructuredContent = $restructured
            ArtifactType = $artifactType
            Analysis = $analysis
        }
    }
    catch {
        Write-Error "Failed to process $FilePath : $_"
        return $null
    }
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

try {
    # Find repository root
    $repoRoot = Get-Location
    while ($repoRoot -and !(Test-Path "$repoRoot\.git")) {
        $repoRoot = Split-Path $repoRoot -Parent
    }
    
    if (-not $repoRoot) {
        throw "Not in a Git repository"
    }
    
    Write-Host "`nDocument Restructuring Tool" -ForegroundColor Cyan
    Write-Host "============================" -ForegroundColor Cyan
    Write-Host "Mode: $(if($DryRun){'DRY RUN'}else{'LIVE'})" -ForegroundColor $(if($DryRun){'Yellow'}else{'Green'})
    Write-Host "`"
    
    # Load document structure from guidelines
    Write-Host "Loading structure guidelines..." -ForegroundColor Gray
    $guidelinesPath = Join-Path $repoRoot "00_Policy\Document_Structure_Guidelines.md"
    if (-not (Test-Path $guidelinesPath)) {
        throw "Cannot find Document_Structure_Guidelines.md at $guidelinesPath"
    }
    
    $structure = Get-DocumentStructure -GuidelinesPath $guidelinesPath
    Write-Host "Loaded $($structure.Keys.Count) artifact type structures`n" -ForegroundColor Green
    
    # Get files to process
    $files = @()
    if ($Recursive) {
        $extensions = @('*.md', '*.ps1', '*.py', '*.sh', '*.yml', '*.yaml', '*.json', '*.xml', '*.config', '*.png', '*.jpg', '*.jpeg', '*.svg', '*.csv')
        $files = Get-ChildItem -Path $FilePath -Include $extensions -Recurse -File
    } else {
        if (Test-Path $FilePath -PathType Leaf) {
            $files = @(Get-Item $FilePath)
        } else {
            Write-Error "$FilePath is not a valid file"
            exit 1
        }
    }
    
    Write-Host "Found $($files.Count) file(s) to process`n" -ForegroundColor Cyan
    
    # Process each file
    $processed = 0
    $skipped = 0
    $commitMessages = @()
    
    foreach ($file in $files) {
        # Skip policy, tools, and git folders
        if ($file.FullName -match '\\(00_Policy|Tools|\.git)\\') {
            Write-Host "Skipping: $($file.FullName)" -ForegroundColor DarkGray
            $skipped++
            continue
        }
        
        # Determine if it's a script file
        $isScript = $file.Extension -in @('.ps1', '.py', '.sh', '.js')
        
        # Get appropriate structure
        $content = Get-Content $file.FullName -Raw -ErrorAction SilentlyContinue
        if (-not $content) {
            Write-Host "Skipping empty file: $($file.FullName)" -ForegroundColor DarkGray
            $skipped++
            continue
        }
        
        $artifactType = Get-ArtifactType -FilePath $file.FullName -Content $content
        $typeStructure = Get-StructureForType -ArtifactType $artifactType -Structure $structure
        
        if (-not $typeStructure) {
            Write-Host "Skipping: No structure for type $artifactType" -ForegroundColor DarkGray
            $skipped++
            continue
        }
        
        # Invoke restructure
        $result = Invoke-DocumentRestructure -FilePath $file.FullName -Structure $typeStructure -IsScript $isScript
        
        if ($result) {
            if ($DryRun) {
                Write-Host "  [DRY RUN] Would update: $($file.FullName)" -ForegroundColor Yellow
                Write-Host "  Preview (first 200 chars): $($result.RestructuredContent.Substring(0, [Math]::Min(200, $result.RestructuredContent.Length)))...`n" -ForegroundColor DarkYellow
            } else {
                # Write restructured content
                Set-Content -Path $file.FullName -Value $result.RestructuredContent -NoNewline
                Write-Host "  Updated: $($file.FullName)" -ForegroundColor Green
                
                # Generate commit message
                $commitMsg = New-CommitMessage -FilePath $file.FullName -Analysis $result.Analysis -ArtifactType $result.ArtifactType
                $commitMessages += @{
                    File = $file.FullName
                    Message = $commitMsg
                }
            }
            $processed++
        }
        
        Write-Host ""
    }
    
    # Summary
    Write-Host "`n============ SUMMARY ============" -ForegroundColor Cyan
    Write-Host "Total files found: $($files.Count)" -ForegroundColor White
    Write-Host "Processed: $processed" -ForegroundColor Green
    Write-Host "Skipped: $skipped" -ForegroundColor Yellow
    Write-Host "Mode: $(if($DryRun){'DRY RUN - No changes made'}else{'LIVE - Files updated'})" -ForegroundColor $(if($DryRun){'Yellow'}else{'Green'})
    
    # Auto-commit if enabled and not dry run
    if ($AutoCommit -and -not $DryRun -and $commitMessages.Count -gt 0) {
        Write-Host "`n============ GIT COMMIT ============" -ForegroundColor Cyan
        foreach ($commit in $commitMessages) {
            try {
                $relativePath = $commit.File.Replace("$repoRoot\\", "")
                git add $commit.File
                git commit -m $commit.Message
                Write-Host "Committed: $relativePath" -ForegroundColor Green
            }
            catch {
                Write-Warning "Failed to commit $($commit.File): $_"
            }
        }
        Write-Host "`nAll changes committed successfully!" -ForegroundColor Green
    }
    
    Write-Host "`nDocument restructuring complete!" -ForegroundColor Cyan
}
catch {
    Write-Error "Script failed: $_"
    exit 1
}
